import random
import music21

# Define available notes
available_notes = ["C", "D", "E", "F", "G", "A", "B"]
scale_mapping_major_scales = {
        "C": ["C", "D", "E", "F", "G", "A", "B"],
        "D": ["D", "E", "F#", "G", "A", "B", "C#"],
        "E": ["E", "F#", "G#", "A", "B", "C#", "D#"],
        "F": ["F", "G", "A", "B-", "C", "D", "E"],
        "G": ["G", "A", "B", "C", "D", "E", "F#"],
        "A": ["A", "B", "C#", "D", "E", "F#", "G#"],
        "B": ["B", "C#", "D#", "E", "F#", "G#", "A#"]
    }
scale_mapping_minor_scales = {
        "C": ["C", "D", "E-", "F", "G", "A-", "B-"],
        "D": ["D", "E", "F", "G", "A", "B-", "C"],
        "E": ["E", "F#", "G", "A", "B", "C", "D"],
        "F": ["F", "G", "A-", "B-", "C", "D-", "E-"],
        "G": ["G", "A", "B-", "C", "D", "E-", "F"],
        "A": ["A", "B", "C", "D", "E", "F", "G"],
        "B": ["B", "C#", "D", "E", "F#", "G", "A"]
    }

def generate_random_melody(desired_key:str, desired_measures:int, scale_map:dict):
    #Where does desired temp fit into this function? : desired_tempo:int
    measure_list_str = []
    measure_list_objects = []
    counts = [1, 2, 4, 8]
    if desired_measures == 8:
        measure_list_str = [ [],[],[],[],[],[],[],[] ]
        measure_list_objects = [ [],[],[],[],[],[],[],[] ]
        # for each measure:
        for i in range(8):
            measure_count = random.choice(counts)
            if measure_count == 1:
                measure_count_str = 'whole'
            if measure_count == 2:
                measure_count_str = 'half'
            if measure_count == 4:
                measure_count_str = 'quarter'
            if measure_count == 8:
                measure_count_str = 'eighth'
            for j in range(measure_count):
                note_choice = random.choice(scale_map[desired_key])
                measure_list_str[i].append(note_choice)
                note_object = music21.note.Note(note_choice, type = measure_count_str)
                measure_list_objects[i].append(note_object)
    
    if desired_measures == 16:
        measure_list_str = [ [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[] ]
        measure_list_objects = [ [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[] ]
        # for each measure:
        for i in range(16):
            measure_count = random.choice(counts)
            if measure_count == 1:
                measure_count_str = 'whole'
            if measure_count == 2:
                measure_count_str = 'half'
            if measure_count == 4:
                measure_count_str = 'quarter'
            if measure_count == 8:
                measure_count_str = 'eighth'
            for j in range(measure_count):
                note_choice = random.choice(scale_map[desired_key])
                measure_list_str[i].append(note_choice)
                note_object = music21.note.Note(note_choice, type = measure_count_str)
                measure_list_objects[i].append(note_object)

    return measure_list_str, measure_list_objects

# Define melody data
class MelodyData:
    def __init__(self, notes):
        self.notes = notes

#def user_options(desired_scale, desired_key,desired_tempo,desired_duration,available_notes):

# Genetic algorithm for melody generation
def generate_melody_with_ga(population_size, generations, fitness_threshold):
    population = [generate_random_melody(desired_duration) for _ in range(population_size)]
    for _ in range(generations):
        population = evolve_population(population, fitness_threshold)
    return population

# Evolve population using genetic operations
def evolve_population(population, fitness_threshold):
    new_population = []
    for _ in range(len(population)):
        parent1, parent2 = select_parents(population)
        child = crossover(parent1, parent2)
        child = mutate(child)
        if fitness(child) >= fitness_threshold:
            return [child]
        new_population.append(child)
    return new_population

# Select parents for crossover
def select_parents(population):
    return random.choices(population, k=2)

# Perform crossover to create child melody
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    return parent1[:crossover_point] + parent2[crossover_point:]

# Perform mutation to introduce diversity
def mutate(melody):
    if random.random() < 0.1:  # Mutation rate
        mutate_index = random.randint(0, len(melody) - 1)
        melody[mutate_index] = random.choice(available_notes)
    return melody

# Evaluate fitness of melody based on user preferences
def fitness(melody):
    # For simplicity, let's assume higher fitness for melodies closer to desired scale and key
    fitness_score = 0
    for note in melody:
        if note in available_notes:
            fitness_score += 1
    return fitness_score 

def create_score(melody):
    """
    Create a music21 score with a given melody (list of notes).
    Returns:
        music21.stream.Score: A music score containing the melody and note
            sequence.
    """
    # Create a Score object
    score = music21.stream.Score()

    # Create the melody part and add notes to it
    melody_part = music21.stream.Part()
    for i, measure in enumerate(melody):
        for j, note in enumerate(measure):
            melody_part.append(note)

    score.append(melody_part)

    return score

# Main function
def main():
    # Generate melodies using genetic algorithm
    melodies = generate_melody_with_ga(population_size=10, generations=1000, fitness_threshold=desired_duration)
    # Print generated melodies
    for i, melody in enumerate(melodies):
        print(f"Melody {i+1}: {' '.join(melody)}")

   #music21_score = create_score()

# Run the main function
if __name__ == "__main__":
    user_scale = (str(input("Enter desired scale: (Major or Minor) "))).upper
    #desired_scale = "C Major"
    if user_scale == "MAJOR":
        user_scale_map = scale_mapping_major_scales
    if user_scale == "MINOR":
        user_scale_map = scale_mapping_minor_scales
    user_key = (str(input("Enter desired key: ('C', 'D', 'E', 'F', 'G', 'A', or 'B') "))).upper
    desired_tempo = 120
    user_measures = (str(input("Enter desired measures: (8 or 16) "))).upper

    note_list_str, note_list_objects = generate_random_melody(user_key, user_measures, user_scale_map)
    print(note_list_str)
    print(note_list_objects)
    
    #print(options_to_notes("C", 8, scale_mapping_minor_scales))
    meep = create_score(note_list_objects)
    meep.show()
    
    main()
